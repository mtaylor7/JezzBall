<!DOCTYPE html>
<meta charset="utf-8">
<title>D3 JezzBall</title>
<style>

form {
  position: absolute;
  top: 1em;
  left: 1em;
}

rect {
  fill: none;
  pointer-events: all;
}

.cell {
}

.cell.wall {
  fill: #000;
}

.cell.air {
  fill: none;
  stroke: #333;
  stroke-opacity: .2;
}

.cell.blue {
  stroke: blue;
  stroke-opacity: .8;
}

.cell.red {
  stroke: red;
  stroke-opacity: .8;
}

.ball {
  fill: red;
  stroke: #333;
  stroke-opacity: .5;
  stroke-width: 2;
}

.builder.head {
  stroke: #333;
  stroke-opacity: .5;
  stroke-width: 2;
}

.builder.blue {
  fill: blue;
}

.builder.red {
  fill: red;
}

.builder.tail {
  fill-opacity: .4;
}


.cell.debug1 {
  fill: #0ff;
  fill-opacity: 1;
}
.cell.debug2 {
  fill: #10f;
  fill-opacity: 1;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<form><input id="switch" type="button" value="V" /></form>
<script>

var w = 960,
    h = 500,
    sz = 20,
    r = sz / 2,
    v = 1.5;

var rows = Math.ceil(h / sz);
var cols = Math.ceil(w / sz);

var s = true;
d3.select("#switch").on("click", function(e) { s = !s; d3.select("#switch").attr("value", s ? "V" : "H"); });

var cells = d3.range(0, rows * cols).map(function (d) {
  var col = d % cols;
  var row = (d - col) / cols;
  return {
    r: row,
    c: col,
    x: col * sz + r,
    y: row * sz + r
  };
});

var svg = d3.select("body").append("svg")
    .attr("width", w)
    .attr("height", h);

var rectx = function(d) { return d.x - r; };
var recty = function(d) { return d.y - r; };

var tailx = function(d) { return d.dx > 0 ? d.sx - r : rectx(d) - d.dx * sz; };
var taily = function(d) { return d.dy > 0 ? d.sy - r : recty(d) - d.dy * sz; };
var tailw = function(d) { return d.dx == 0 ? sz : d.sz = (d.x - d.sx) * d.dx; };
var tailh = function(d) { return d.dy == 0 ? sz : d.sz = (d.y - d.sy) * d.dy; };

var ballCell = function(b) {
  var row = (b.y - b.y % sz) / sz;
  var col = (b.x - b.x % sz) / sz;
  return cells[row * cols + col];
};

var topCell = function(c) { return cells[(c.r - 1) * cols + c.c]; };
var leftCell = function(c) { return cells[c.r * cols + c.c - 1]; };
var bottomCell = function(c) { return cells[(c.r + 1) * cols + c.c]; };
var rightCell = function(c) { return cells[c.r * cols + c.c + 1]; };

var topLeftCell = function(c) { return cells[(c.r - 1) * cols + c.c - 1]; };
var bottomLeftCell = function(c) { return cells[(c.r + 1) * cols + c.c - 1]; };
var bottomRightCell = function(c) { return cells[(c.r + 1) * cols + c.c + 1]; };
var topRightCell = function(c) { return cells[(c.r - 1) * cols + c.c + 1]; };

var blue, red;
var cell = svg.selectAll(".cell")
  .data(cells)
  .enter().append("rect")
  .attr("class", function(d) { return "cell " + ((d.isWall = d.x == r || d.x == w - r || d.y == r || d.y == h - r) ? "wall" : "air"); })
  .attr("x", rectx)
  .attr("y", recty)
  .attr("width", sz)
  .attr("height", sz)
  .on("mouseover", function(c1) {
    var p = d3.mouse(this);
    var dx = s ? (p[0] - c1.x > 0 ? 1 : -1) : 0;
    var dy = s ? 0 : (p[1] - c1.y > 0 ? 1 : -1); 
    var a = d3.select(this);
    var b = svg.selectAll(".cell").filter(function(c2) { return c2.x == c1.x + sz * dx && c2.y == c1.y + sz * dy; });
    if (dx + dy > 0) {
      blue = a;
      red = b;
    } else {
      blue = b;
      red = a;
    }
    blue.classed("blue", true);
    red.classed("red", true);
  }).on("mouseout", function(c1) {
    blue.classed("blue", false);
    red.classed("red", false);
  }).on("click", function() {
    var dx = s ? 1 : 0;
    var dy = s ? 0 : 1; 
    blue.each(function(d) { startWall(d, "blue", -dx, -dy); });
    red.each(function(d) { startWall(d, "red", dx, dy); });
  });

var b1x = (w - sz * 4) * Math.random() + sz * 2;
var b1y = (h - sz * 4) * Math.random() + sz * 2;
var b2x = (w - sz * 4) * Math.random() + sz * 2;
var b2y = (h - sz * 4) * Math.random() + sz * 2;
var ball1 = {
    x: b1x,
    y: b1y,
    px: b1x + v,
    py: b1y + v,
    id: 1,
    isMoving: true
  },
  ball2 = {
    x: b2x,
    y: b2y,
    px: b2x - v,
    py: b2y - v,
    id: 2,
    isMoving: true
  };

var balls = [ball1, ball2];

var force = d3.layout.force()
  .gravity(0)
  .charge(0)
  .friction(1)
  .size([w, h]);

balls.forEach(function (b) {
  svg.append("svg:circle")
    .data([b])
    .attr("class", "ball")
    .attr("cx", function (d) {
    return d.x;
  })
    .attr("cy", function (d) {
    return d.y;
  })
    .attr("r", r);
  force.nodes().push(b);
});

force.on("tick", function () {
  var tail = svg.selectAll(".tail");
  var wall = svg.selectAll(".cell.wall");
  var air = svg.selectAll(".cell.air");
  var head = svg.selectAll(".head");
  var ball = svg.selectAll(".ball");
  
  var wallWasBuilt = false;
  
  head.attr("x", function(d) { d.x += d.dx * v; return rectx(d); })
    .attr("y", function(d) { d.y += d.dy * v; return recty(d); })
    .each(function(d) {
      svg.select("." + d.cl + ".tail")
        .attr("x", tailx)
        .attr("y", taily)
        .attr("width", tailw)
        .attr("height", tailh);
    });
  head.filter(function(h) {
      return !wall.filter(function(w) { return h.dx == 0 ? h.x == w.x && Math.abs(h.y - w.y) < sz : h.y == w.y && Math.abs(h.x - w.x) < sz; }).empty();
    }).each(function(h) {
      air.filter(function(a) {
          return h.dx == 0 ? h.x == a.x && Math.min(h.sy, h.y) <= a.y && a.y <= Math.max(h.sy, h.y) : h.y == a.y && Math.min(h.sx, h.x) <= a.x && a.x <= Math.max(h.sx, h.x);
        })
        .classed("air", false)
        .classed("wall", true)
        .each(function(d) { d.isWall = true; });
      tail.filter("." + h.cl)
        .remove();
      wallWasBuilt = true;
    }).remove();
  
  ball.attr("cx", function (d) { return d.x; })
    .attr("cy", function (d) { return d.y; })
    .each(function(b) {
      if (!b.isMoving) {
        return;
      }
      
      if (wallWasBuilt) {
        fillEmptyRooms();
      }
      
      var dx = b.x - b.px > 0 ? 1 : -1;
      var dy = b.y - b.py > 0 ? 1 : -1;
      var d;
      
      var cc = ballCell(b);
      var tc = topCell(cc);
      if (tc.isWall && dy < 0 && (d = b.y - tc.y) <= sz) {
        b.y += sz - d;
        b.py = b.y + dy * v;
      }
      var lc = leftCell(cc);
      if (lc.isWall && dx < 0 && (d = b.x - lc.x) <= sz) {
        b.x += sz - d;
        b.px = b.x + dx * v;
      }
      var bc = bottomCell(cc);
      if (bc.isWall && dy > 0 && (d = bc.y - b.y) <= sz) {
        b.y -= sz - d;
        b.py = b.y + dy * v;
      }
      var rc = rightCell(cc);
      if (rc.isWall && dx > 0 && (d = rc.x - b.x) <= sz) {
        b.x -= sz - d;
        b.px = b.x + dx * v;
      }
      var tlc = topLeftCell(cc);
      if (tlc.isWall && (d = (b.x - (tlc.x + r)) * (b.x - (tlc.x + r)) + (b.y - (tlc.y + r)) * (b.y - (tlc.y + r))) <= r * r) {
        if (dx < 0) {
          b.x += r - Math.sqrt(d);
          b.px = b.x + dx * v;
        }
        if (dy < 0) {
          b.y += r - Math.sqrt(d);
          b.py = b.y + dy * v;
        }
      }
      var blc = bottomLeftCell(cc);
      if (blc.isWall && (d = (b.x - (blc.x + r)) * (b.x - (blc.x + r)) + ((blc.y - r) - b.y) * ((blc.y - r) - b.y)) <= r * r) {
        if (dx < 0) {
          b.x += r - Math.sqrt(d);
          b.px = b.x + dx * v;
        }
        if (dy > 0) {
          b.y -= r - Math.sqrt(d);
          b.py = b.y + dy * v;
        }
      }
      var brc = bottomRightCell(cc);
      if (brc.isWall && (d = ((brc.x - r) - b.x) * ((brc.x - r) - b.x) + ((brc.y - r) - b.y) * ((brc.y - r) - b.y)) <= r * r) {
        if (dx > 0) {
          b.x -= r - Math.sqrt(d);
          b.px = b.x + dx * v;
        }
        if (dy > 0) {
          b.y -= r - Math.sqrt(d);
          b.py = b.y + dy * v;
        }
      }
      var trc = topRightCell(cc);
      if (trc.isWall && (d = ((trc.x - r) - b.x) * ((trc.x - r) - b.x) + (b.y - (trc.y + r)) * (b.y - (trc.y + r))) <= r * r) {
        if (dx > 0) {
          b.x -= r - Math.sqrt(d);
          b.px = b.x + dx * v;
        }
        if (dy < 0) {
          b.y += r - Math.sqrt(d);
          b.py = b.y + dy * v;
        }
      }
      if (cc.isWall || (tc.isWall && bc.isWall) || (lc.isWall && rc.isWall)) {
        svg.selectAll(".cell")
          .filter(function(d) { return d.r == cc.r && d.c == cc.c; })
          .classed("air", true)
          .classed("wall", false);
        b.px = b.x = cc.x;
        b.py = b.y = cc.y;
        cc.isWall = b.isMoving = false;
      }
      
      tail.filter(function(t) {
          var w = tailw(t);
          var h = tailh(t);
          if (w == 0 || h == 0) {
            return false;
          }
          var x0 = tailx(t);
          var x1 = tailx(t) + w;
          var y0 = taily(t);
          var y1 = taily(t) + h;
          return intersect(b.px, b.py, b.x, b.y, x0 - r, y0, x0 - r, y1)
              || intersect(b.px, b.py, b.x, b.y, x1 + r, y0, x1 + r, y1)
              || intersect(b.px, b.py, b.x, b.y, x0, y0 - r, x1, y0 - r)
              || intersect(b.px, b.py, b.x, b.y, x0, y1 + r, x1, y1 + r);
        })
        .each(function(t) {
            svg.selectAll(".head." + t.cl).remove();
          })
        .remove();
      });
  
  force.resume();
});

force.start();

function fillEmptyRooms() {
  d3.selectAll(".cell.air")
    .each(function (d) {
      d.visited = false;
    });
  
  var pending = d3.selectAll(".cell.air")
    .classed("pending", true);
  
  svg.selectAll(".ball")
    .each(function (b) {
      var cc = ballCell(b);
      pending
        .filter(function (c) {
            return cc.r == c.r && cc.c == c.c;
          })
        .classed("pending", false)
        .each(function (c) {
            c.visited = true;
            visit(pending, c.x, c.y);
          });
    });
  
  d3.selectAll(".pending")
    .classed("wall", true)
    .classed("air", false)
    .each(function(d) { d.isWall = true; });
}

function visit(cells, x, y) {
  cells
    .filter(function (d) {
        return !d.visited && ((y == d.y && (x - sz == d.x || d.x == x + sz)) || (x == d.x && (y - sz == d.y || d.y == y + sz)));
      })
    .classed("pending", false)
    .each(function (c) {
        c.visited = true;
        visit(cells, c.x, c.y);
      });
}

function startWall(cell, cl, dx, dy) {
  var wallHead = {
    sx: cell.x,
    sy: cell.y,
    x: cell.x,
    y: cell.y,
    dx: dx,
    dy: dy,
    cl: cl
  };
  if (svg.selectAll("." + cl + ".head").empty()) {
    svg.selectAll("." + cl + ".head")
      .data([wallHead]).enter().append("rect")
      .classed("builder", true)
      .classed(cl, true)
      .classed("head", true)
      .attr("x", rectx)
      .attr("y", recty)
      .attr("width", sz)
      .attr("height", sz);
    var tail = svg.selectAll("." + cl + ".tail")
      .data([wallHead]);
    tail.enter().append("rect")
      .classed("builder", true)
      .classed(cl, true)
      .classed("tail", true)
      .attr("x", tailx)
      .attr("y", taily)
      .attr("width", tailw)
      .attr("height", tailh);
    tail.exit().remove();
  }
}

function intersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
  var ua_t = (b2x - b1x) * (a1y - b1y) - (b2y - b1y) * (a1x - b1x);
  var ub_t = (a2x - a1x) * (a1y - b1y) - (a2y - a1y) * (a1x - b1x);
  var u_b = (b2y - b1y) * (a2x - a1x) - (b2x - b1x) * (a2y - a1y);

  if (u_b != 0) {
    var ua = ua_t / u_b;
    var ub = ub_t / u_b;

    return 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1;
  } else {
    return true;
  }
}


</script>