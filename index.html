<!DOCTYPE html>
<html>
  <style>
    body {
      font-family:"Helvetica Neue", Helvetica, Arial, sans-serif;
      width: 960px;
      height: 500px;
      position: relative;
    }
    form {
      position: absolute;
      top: 1em;
      left: 1em;
    }
    rect {
      fill: none;
      pointer-events: all;
    }
    rect.bt, rect.lr {
      fill: #33f;
      fill-opacity: .6;
    }
    rect.tb, rect.rl {
      fill: #f33;
      fill-opacity: .6;
    }
    rect.wall {
      fill: #000;
      fill-opacity: .1;
    }
    rect.wall0 {
      fill: #000;
      fill-opacity: .3;
    }
    .ball {
      fill: red;
    }
    rect.cell {
      stroke: #333;
      stroke-opacity: .2;
    }
    rect.blackcell {
      fill: #000;
    }
  </style>
  <script src="http://d3js.org/d3.v3.min.js"></script>
  <form><input id="switch" type="button" value="V" /></form>
  <div id="chart"></div>
  <script type="text/javascript">
    var w = 960,
      h = 500,
      r = 10,
      v = 5,
      sz = 20;

    var ball1 = {
      x: (w / 2),
      y: (h / 2),
      px: (w / 2 - v),
      py: (h / 2 - v)
    },
      ball2 = {
        x: (w / 2),
        y: (h / 2),
        px: (w / 2 + v),
        py: (h / 2 + v)
      };

    var balls = [ball1, ball2];

    var force = d3.layout.force()
      .gravity(0)
      .charge(0)
      .friction(1)
      .size([w, h]);

    var svg = d3.select("#chart").append("svg:svg")
      .attr("width", w)
      .attr("height", h);

    svg.append("svg:rect")
      .attr("width", w)
      .attr("height", h);

    var rows = Math.ceil(h / sz);
    var cols = Math.ceil(w / sz);
    
    var cells = d3.range(0, rows * cols).map(function (d) {
      return {
        x: (d % cols) * sz,
        y: (Math.floor(d / cols) % rows) * sz
      };
    });
    
    svg.selectAll(".cell").data(cells).enter()
      .append("rect")
      .attr("class", "cell")
      .attr("x", function (d) {
        return d.x;
      })
      .attr("y", function (d) {
        return d.y;
      })
      .attr("width", sz)
      .attr("height", sz);


    function a(d) {
      if (svg.selectAll("." + d.c).empty()) {
        svg.selectAll("." + d.c)
          .data([d]).enter().append("rect")
          .attr("class", d.c + " wallbuilder")
          .attr("x", d.x)
          .attr("y", d.y)
          .attr("width", d.w)
          .attr("height", d.h);
      }
    }

    var s = true;
    d3.select("#switch").on("click", function(e) { s = !s; d3.select("#switch").attr("value", s ? "V" : "H"); })

    svg.on("click", function () {
      var p = d3.mouse(this);
      var bx = p[0],
        by = s ? p[1] - sz : p[1];
      var blue = {
        x: Math.round(bx / sz) * sz,
        y: Math.round(by / sz) * sz,
        w: sz,
        h: sz,
        c: s ? "bt" : "lr"
      };
      a(blue);
      var rx = s ? p[0] : p[0] - sz,
        ry = p[1];
      var red = {
        x: Math.round(rx / sz) * sz,
        y: Math.round(ry / sz) * sz,
        w: sz,
        h: sz,
        c: s ? "tb" : "rl"
      };
      a(red);
    })

     force.on("tick", function () {
      svg.selectAll("circle")
        .attr("cx", function (d) {
        var dx = d.px - d.x;
        var m = w - r;
        if (d.x < r) {
          d.x = r + (r - d.x);
          d.px = d.x - dx;
        } else if (d.x > m) {
          d.x = m - (d.x - m);
          d.px = d.x - dx;
        }
        return d.x;
      })
        .attr("cy", function (d) {
        var dy = d.py - d.y;
        var m = h - r;
        if (d.y < r) {
          d.y = r + (r - d.y);
          d.py = d.y - dy;
        } else if (d.y > m) {
          d.y = m - (d.y - m);
          d.py = d.y - dy;
        }
        return d.y;
      });

      svg.selectAll(".ball")
        .each(function (b) {
        var walls = svg.selectAll(".wall");
        var builders = svg.selectAll(".wallbuilder");
        var first = function (d, i) {
          return i == 0;
        };
        if (b.px < b.x) {
          var f = function (w) {
            return intersect({
              x: b.px + r,
              y: b.py
            }, {
              x: b.x + r,
              y: b.y
            }, w, {
              x: w.x,
              y: w.y + w.h
            });
          };
          walls.filter(f).filter(first).each(function (d) {
            var m = d.x - r;
            var dx = b.px - b.x;
            b.x = m - (b.x - m);
            b.px = b.x - dx;
          });
          builders.filter(f).remove();
        } else {
          var f = function (w) {
            return intersect({
              x: b.px - r,
              y: b.py
            }, {
              x: b.x - r,
              y: b.y
            }, {
              x: w.x + w.w,
              y: w.y
            }, {
              x: w.x + w.w,
              y: w.y + w.h
            });
          };
          walls.filter(f).filter(first).each(function (d) {
            var m = d.x + d.w + r;
            var dx = b.px - b.x;
            b.x = m + (m - b.x);
            b.px = b.x - dx;
          });
          builders.filter(f).remove();
        }
        if (b.py < b.y) {
          var f = function (w) {
            return intersect({
              x: b.px,
              y: b.py + r
            }, {
              x: b.x,
              y: b.y + r
            }, w, {
              x: w.x + w.w,
              y: w.y
            });
          };
          walls.filter(f).filter(first).each(function (d) {
            var m = d.y - r;
            var dy = b.py - b.y;
            b.y = m - (b.y - m);
            b.py = b.y - dy;
          });
          builders.filter(f).remove();
        } else {
          var f = function (w) {
            return intersect({
              x: b.px,
              y: b.py - r
            }, {
              x: b.x,
              y: b.y - r
            }, {
              x: w.x,
              y: w.y + w.h
            }, {
              x: w.x + w.w,
              y: w.y + w.h
            });
          };
          walls.filter(f).filter(first).each(function (d) {
            var m = d.y + d.h + r;
            var dy = b.py - b.y;
            b.y = m + (m - b.y);
            b.py = b.y - dy;
          });
          builders.filter(f).remove();
        }
      })


var walls = d3.selectAll(".blackcell");
function wallAhead(x, y) {
  return !walls.filter(function(w) {
                      return w.x == x && w.y == y;
                    }).empty()
}

      // bottom to top
      svg.selectAll(".bt")
        .attr("y", function (d) {
        return d.y = d.y - v;
      })
        .attr("height", function (d) {
        return d.h = d.h + v;
      }).filter(function (d) {
        return d.y <= 0 || wallAhead(d.x, d.y - d.y % sz);
      }).attr("class", "wall").each(fillEmptyRooms);

      // left to right
      svg.selectAll(".lr")
        .attr("width", function (d) {
        return d.w = d.w + v;
      }).filter(function (d) {
        return d.x + d.w >= w || wallAhead(d.x + (d.w - d.w % sz), d.y);
      }).attr("class", "wall").each(fillEmptyRooms);

      // top to bottom
      svg.selectAll(".tb")
        .attr("height", function (d) {
        return d.h = d.h + v;
      }).filter(function (d) {
        return d.y + d.h >= h || wallAhead(d.x, d.y + (d.h - d.h % sz));
      }).attr("class", "wall").each(fillEmptyRooms);

      // right to left
      svg.selectAll(".rl")
        .attr("x", function (d) {
          return d.x = d.x - v;
        })
        .attr("width", function (d) {
          return d.w = d.w + v;
        })
        .filter(function (d) {
          return d.x <= 0 || wallAhead(d.x - d.x % sz, d.y);
        })
        .attr("class", "wall").each(fillEmptyRooms);

      force.resume();
    });

    function fillEmptyRooms(d) {
      d.x = Math.round(d.x / sz) * sz;
      d.y = Math.round(d.y / sz) * sz;
      d.w = Math.round(d.w / sz) * sz;
      d.h = Math.round(d.h / sz) * sz;
      var cells = d3.selectAll(".cell");
      var xmax = d.x + d.w;
      var ymax = d.y + d.h
      for (var x = d.x; x < xmax; x += sz) {
        for (var y = d.y; y < ymax; y += sz) {
          cells.filter(function (d) {
            return d.x == x && d.y == y;
          }).attr("class", "blackcell");
        }
      }
      var pending = d3.selectAll(".cell").attr("class", "pending");
      var balls = d3.selectAll(".ball").each(function (d) {
        var x = d.x - d.x % sz;
        var y = d.y - d.y % sz;
        pending.filter(function (d) {
          return y == d.y && x == d.x;
        }).attr("class", "cell")
          .each(function (c) {
          c.visited = true;
          visit(pending, c.x, c.y);
        });
      });
      d3.selectAll(".pending").attr("class", "blackcell");
      d3.selectAll(".cell").each(function (d) {
        d.visited = false;
      });
    }
    balls.forEach(function (b) {
      svg.append("svg:circle")
        .data([b])
        .attr("class", "ball")
        .attr("cx", function (d) {
        return d.x;
      })
        .attr("cy", function (d) {
        return d.y;
      })
        .attr("r", r);
      force.nodes().push(b);
    });

    force.start();

    function visit(cells, x, y) {
      cells
        .filter(function (d) {
        return !d.visited && ((y == d.y && (x - sz == d.x || d.x == x + sz)) || (x == d.x && (y - sz == d.y || d.y == y + sz)));
      })
        .attr("class", "cell")
        .each(function (c) {
        c.visited = true;
        visit(cells, c.x, c.y);
      });
    }

    function intersect(a1, a2, b1, b2) {
      var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
      var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
      var u_b = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

      if (u_b != 0) {
        var ua = ua_t / u_b;
        var ub = ub_t / u_b;

        return 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1;
      } else {
        return true;
      }
    };
  </script>